// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package avsregistry

import (
	"github.com/Layr-Labs/eigensdk-go/chainio/clients/elcontracts"
	"github.com/Layr-Labs/eigensdk-go/chainio/clients/eth"
	"github.com/Layr-Labs/eigensdk-go/chainio/txmgr"
	"github.com/Layr-Labs/eigensdk-go/logging"
)

// Injectors from wire_builder.go:

func NewReaderFromConfig(cfg Config, ethClient eth.Client, logger logging.Logger) (*ChainReader, error) {
	contractBindings, err := NewBindingsFromConfig(cfg, ethClient, logger)
	if err != nil {
		return nil, err
	}
	chainReader := NewChainReaderFromBindings(contractBindings, ethClient, logger)
	return chainReader, nil
}

func NewWriterFromConfig(cfg Config, ethClient eth.Client, txMgr txmgr.TxManager, logger logging.Logger) (*ChainWriter, error) {
	contractBindings, err := NewBindingsFromConfig(cfg, ethClient, logger)
	if err != nil {
		return nil, err
	}
	config := NewElConfigFromAvsBindings(contractBindings)
	chainReader, err := elcontracts.NewReaderFromConfig(config, ethClient, logger)
	if err != nil {
		return nil, err
	}
	chainWriter := NewChainWriterFromBindings(contractBindings, chainReader, logger, ethClient, txMgr)
	return chainWriter, nil
}

// Note that unlike reader/writer, a websocket eth client must be provided
func NewSubscriberFromConfig(cfg Config, wsClient eth.Client, logger logging.Logger) (*ChainSubscriber, error) {
	contractBindings, err := NewBindingsFromConfig(cfg, wsClient, logger)
	if err != nil {
		return nil, err
	}
	chainSubscriber := NewChainSubscriberFromBindings(contractBindings, logger)
	return chainSubscriber, nil
}

func buildClientsFromConfig(cfg Config, ethHttpClient eth.Client, ethWsClient2 ethWsClient, txMgr txmgr.TxManager, logger logging.Logger) (*ClientsAndBindings, error) {
	chainReader, err := NewReaderFromConfig(cfg, ethHttpClient, logger)
	if err != nil {
		return nil, err
	}
	chainWriter, err := NewWriterFromConfig(cfg, ethHttpClient, txMgr, logger)
	if err != nil {
		return nil, err
	}
	chainSubscriber, err := newSubscriberFromConfigWithEthWsClientType(cfg, ethWsClient2, logger)
	if err != nil {
		return nil, err
	}
	contractBindings, err := NewBindingsFromConfig(cfg, ethHttpClient, logger)
	if err != nil {
		return nil, err
	}
	clientsAndBindings := &ClientsAndBindings{
		ChainReader:      chainReader,
		ChainWriter:      chainWriter,
		ChainSubscriber:  chainSubscriber,
		ContractBindings: contractBindings,
	}
	return clientsAndBindings, nil
}

// wire_builder.go:

// including here because needed in NewWriterFromConfig
func NewElConfigFromAvsBindings(
	bindings *ContractBindings,
) elcontracts.Config {
	return elcontracts.Config{

		DelegationManagerAddress: bindings.DelegationManagerAddr,
		AvsDirectoryAddress:      bindings.AvsDirectoryAddr,
	}
}

type ClientsAndBindings struct {
	ChainReader      *ChainReader
	ChainWriter      *ChainWriter
	ChainSubscriber  *ChainSubscriber
	ContractBindings *ContractBindings
}

// ============= Workaround Code =================
// this section is needed because wire does not allow a Build dependency graph
// with two dependencies of the same type. See:
// https://github.com/google/wire/blob/main/docs/faq.md#what-if-my-dependency-graph-has-two-dependencies-of-the-same-type
// In BuildClientsFromConfig since both ethHttpClient and ethWsClient have type eth.Client,
// we need to wrap one of them in a new type to avoid the error.
type ethWsClient eth.Client

func newEthWsClient(
	wsClient eth.Client,
) ethWsClient {
	return (ethWsClient)(wsClient)
}

func newSubscriberFromConfigWithEthWsClientType(
	cfg Config,
	wsClient ethWsClient,
	logger logging.Logger,
) (*ChainSubscriber, error) {
	return NewSubscriberFromConfig(cfg, eth.Client(wsClient), logger)
}

func BuildClientsFromConfig(
	cfg Config,
	ethHttpClient eth.Client, ethWsClient2 eth.Client,

	txMgr txmgr.TxManager,
	logger logging.Logger,
) (*ClientsAndBindings, error) {
	return buildClientsFromConfig(cfg, ethHttpClient, ethWsClient2, txMgr, logger)
}
